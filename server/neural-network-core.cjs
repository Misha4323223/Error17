/**
 * üß† BOOOMERANGS NEURAL CORE - TRANSFORMER ARCHITECTURE
 * –ü—Ä–µ–≤—Ä–∞—â–∞–µ–º —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫—É—é —Å–∏—Å—Ç–µ–º—É –≤ –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—É—é –Ω–µ–π—Ä–æ—Å–µ—Ç—å —É—Ä–æ–≤–Ω—è GPT-3
 */

const tf = require('@tensorflow/tfjs-node');

class BooomerangsNeuralCore {
  constructor() {
    this.model = null;
    this.isTraining = false;
    this.semanticMemory = null;
    this.trainingData = [];
    this.vocabulary = new Map();
    this.reverseVocabulary = new Map();
    this.vocabSize = 0;
    this.maxSequenceLength = 512;
    this.embeddingDim = 768;
    this.numHeads = 12;
    this.numLayers = 12; // –£–≤–µ–ª–∏—á–µ–Ω–æ –¥–æ —É—Ä–æ–≤–Ω—è GPT-3
    this.hiddenSize = 3072;

    console.log('üß† –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è BOOOMERANGS Neural Core...');
  }

  async initialize() {
    console.log('üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è BOOOMERANGS Neural Core...');

    // –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–π –ø–∞–º—è—Ç–∏
    try {
      const semanticModule = require('./semantic-memory/index.cjs');
      this.semanticMemory = semanticModule;
      console.log('‚úÖ –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è –ø–∞–º—è—Ç—å –ø–æ–¥–∫–ª—é—á–µ–Ω–∞');
    } catch (error) {
      console.log('‚ö†Ô∏è –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è –ø–∞–º—è—Ç—å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞, —Ä–∞–±–æ—Ç–∞–µ–º –∞–≤—Ç–æ–Ω–æ–º–Ω–æ');
    }

    // –ü—ã—Ç–∞–µ–º—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –º–æ–¥–µ–ª—å
    const modelLoaded = await this.loadModel();
    
    if (!modelLoaded) {
      console.log('üèóÔ∏è –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π transformer –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã...');
      
      // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞—ë–º —Å–ª–æ–≤–∞—Ä—å
      await this.buildVocabulary();

      // –°–æ–∑–¥–∞—ë–º transformer –º–æ–¥–µ–ª—å
      this.model = await this.createAdvancedTransformer();
      
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ–∑–¥–∞–Ω–Ω—É—é –º–æ–¥–µ–ª—å
      console.log('üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–æ–≤–æ–π –º–æ–¥–µ–ª–∏...');
      await this.saveModel();
    }

    console.log('üéâ BOOOMERANGS Neural Core –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!');
    console.log('üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –º–æ–¥–µ–ª–∏:');
    const stats = this.getModelStats();
    console.log(`   - –ü–∞—Ä–∞–º–µ—Ç—Ä—ã: ${stats.totalParams.toLocaleString()}`);
    console.log(`   - –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞: ${stats.architecture}`);
    console.log(`   - –ü–∞–º—è—Ç—å: ~${stats.memoryEstimate.estimatedMB} –ú–ë`);
    
    return this;
  }

  async buildVocabulary() {
    console.log('üìö –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —Å–ª–æ–≤–∞—Ä—è...');

    // –û—á–∏—â–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Å–ª–æ–≤–∞—Ä–∏
    this.vocabulary.clear();
    this.reverseVocabulary.clear();

    // –ë–∞–∑–æ–≤—ã–π —Å–ª–æ–≤–∞—Ä—å —Å —Ä—É—Å—Å–∫–∏–º–∏ —Ç–æ–∫–µ–Ω–∞–º–∏
    const baseTokens = [
      '<PAD>', '<UNK>', '<START>', '<END>',
      '—á—Ç–æ', '–∫–∞–∫', '–≥–¥–µ', '–∫–æ–≥–¥–∞', '–ø–æ—á–µ–º—É', '–∫–æ—Ç–æ—Ä—ã–π', '–∫–∞–∫–æ–π',
      '–∏', '–≤', '–Ω–∞', '—Å', '–ø–æ', '–¥–ª—è', '–æ—Ç', '–¥–æ', '–∑–∞', '–ø—Ä–∏',
      '—ç—Ç–æ', '—Ç–æ', '–≤—Å–µ', '—Ç–∞–∫', '—É–∂–µ', '—Ç–æ–ª—å–∫–æ', '–µ—â–µ', '–∏–ª–∏',
      'booomerangs', 'ai', '–Ω–µ–π—Ä–æ—Å–µ—Ç—å', '—Å–µ–º–∞–Ω—Ç–∏–∫–∞', '–∞–Ω–∞–ª–∏–∑',
      '–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ', '–≤–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏—è', '–¥–∏–∑–∞–π–Ω', '–≤—ã—à–∏–≤–∫–∞',
      '—Å–æ–∑–¥–∞—Ç—å', '—Å–¥–µ–ª–∞—Ç—å', '–ø–æ–ª—É—á–∏—Ç—å', '–Ω–∞–π—Ç–∏', '–ø–æ–Ω—è—Ç—å', '–∑–Ω–∞—Ç—å'
    ];

    // –î–æ–±–∞–≤–ª—è–µ–º –±–∞–∑–æ–≤—ã–µ —Ç–æ–∫–µ–Ω—ã —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ—Å—Ç–∏
    baseTokens.forEach((token, index) => {
      this.vocabulary.set(token, index);
      this.reverseVocabulary.set(index, token);
      console.log(`üìù –î–æ–±–∞–≤–ª–µ–Ω —Ç–æ–∫–µ–Ω: ${index} -> "${token}"`);
    });

    // –î–æ–±–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–π –ø–∞–º—è—Ç–∏
    if (this.semanticMemory) {
      try {
        const interactions = await this.semanticMemory.getAllInteractions?.() || [];
        const allText = interactions.map(i => `${i.query} ${i.response}`).join(' ');
        const words = allText.toLowerCase().match(/\b\w+\b/g) || [];

        const wordFreq = new Map();
        words.forEach(word => {
          wordFreq.set(word, (wordFreq.get(word) || 0) + 1);
        });

        // –î–æ–±–∞–≤–ª—è–µ–º —á–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ —Å–ª–æ–≤–∞
        Array.from(wordFreq.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, 10000)
          .forEach(([word]) => {
            if (!this.vocabulary.has(word)) {
              const index = this.vocabulary.size;
              this.vocabulary.set(word, index);
              this.reverseVocabulary.set(index, word);
            }
          });
      } catch (error) {
        console.log('‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–π –ø–∞–º—è—Ç–∏');
      }
    }

    this.vocabSize = this.vocabulary.size;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç—å —Å–ª–æ–≤–∞—Ä–µ–π
    this.validateVocabularies();
    
    console.log(`‚úÖ –°–ª–æ–≤–∞—Ä—å –ø–æ—Å—Ç—Ä–æ–µ–Ω: ${this.vocabSize} —Ç–æ–∫–µ–Ω–æ–≤`);
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ —Å–ª–æ–≤–∞—Ä–µ–π
   */
  validateVocabularies() {
    console.log('üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ —Å–ª–æ–≤–∞—Ä–µ–π...');
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä—ã
    if (this.vocabulary.size !== this.reverseVocabulary.size) {
      throw new Error(`–†–∞–∑–º–µ—Ä—ã —Å–ª–æ–≤–∞—Ä–µ–π –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç: vocabulary=${this.vocabulary.size}, reverseVocabulary=${this.reverseVocabulary.size}`);
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –∫–ª—é—á–µ–π –∏ –∑–Ω–∞—á–µ–Ω–∏–π
    let errors = 0;
    for (const [word, index] of this.vocabulary.entries()) {
      const reverseWord = this.reverseVocabulary.get(index);
      if (reverseWord !== word) {
        console.error(`‚ùå –ù–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ: vocabulary["${word}"] = ${index}, –Ω–æ reverseVocabulary[${index}] = "${reverseWord}"`);
        errors++;
      }
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ—Å—Ç—å –∏–Ω–¥–µ–∫—Å–æ–≤
    const indices = Array.from(this.reverseVocabulary.keys()).sort((a, b) => a - b);
    for (let i = 0; i < indices.length; i++) {
      if (indices[i] !== i) {
        console.error(`‚ùå –ü—Ä–æ–ø—É—Å–∫ –∏–Ω–¥–µ–∫—Å–∞: –æ–∂–∏–¥–∞–ª—Å—è ${i}, –Ω–∞–π–¥–µ–Ω ${indices[i]}`);
        errors++;
      }
    }
    
    if (errors > 0) {
      throw new Error(`–ù–∞–π–¥–µ–Ω–æ ${errors} –æ—à–∏–±–æ–∫ –≤ —Å–ª–æ–≤–∞—Ä—è—Ö`);
    }
    
    console.log('‚úÖ –°–ª–æ–≤–∞—Ä–∏ –ø—Ä–æ—à–ª–∏ –ø—Ä–æ–≤–µ—Ä–∫—É —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏');
  }

  async createAdvancedTransformer() {
    console.log('üèóÔ∏è –°–æ–∑–¥–∞–Ω–∏–µ Transformer –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã —Å streaming –∑–∞–≥—Ä—É–∑–∫–æ–π...');
    
    // –ü–æ–¥–∫–ª—é—á–∞–µ–º Memory Monitor
    const { getGlobalMemoryMonitor } = require('./memory-monitor.cjs');
    const memoryMonitor = getGlobalMemoryMonitor();
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞–º—è—Ç—å –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º
    const initialMemory = memoryMonitor.getCurrentMemoryStatus();
    console.log(`üß† –ü–∞–º—è—Ç—å –ø–µ—Ä–µ–¥ —Å–æ–∑–¥–∞–Ω–∏–µ–º: ${initialMemory.usagePercentFormatted} (${initialMemory.freeMB}MB —Å–≤–æ–±–æ–¥–Ω–æ)`);
    
    // Input layer
    console.log('üì• –°–æ–∑–¥–∞–Ω–∏–µ input —Å–ª–æ—è...');
    const input = tf.input({ shape: [this.maxSequenceLength] });
    
    // –ü–∞—É–∑–∞ –¥–ª—è –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è event loop
    await new Promise(resolve => setTimeout(resolve, 100));

    // Embedding + Positional Encoding
    console.log('üî§ –°–æ–∑–¥–∞–Ω–∏–µ embedding —Å–ª–æ—ë–≤...');
    let embeddings = tf.layers.embedding({
      inputDim: this.vocabSize,
      outputDim: this.embeddingDim,
      maskZero: true,
      name: 'token_embeddings'
    }).apply(input);

    // –ü–∞—É–∑–∞ –¥–ª—è –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è event loop
    await new Promise(resolve => setTimeout(resolve, 100));

    // –ü—Ä–æ—Å—Ç–æ–µ positional encoding –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –ø—Ä–æ–±–ª–µ–º —Å —Ñ–æ—Ä–º–æ–π
    const positionInput = tf.input({ shape: [this.maxSequenceLength] });
    
    console.log('üìç –°–æ–∑–¥–∞–Ω–∏–µ positional encoding...');
    // Positional encoding layer
    const positionEmbedding = tf.layers.embedding({
      inputDim: this.maxSequenceLength,
      outputDim: this.embeddingDim,
      name: 'position_embeddings'
    }).apply(positionInput);
    
    // –ü–∞—É–∑–∞ –¥–ª—è –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è event loop
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // –°—É–º–º–∏—Ä—É–µ–º token –∏ position embeddings
    const combinedEmbeddings = tf.layers.add({
      name: 'combined_embeddings'
    }).apply([embeddings, positionEmbedding]);
    
    console.log('‚úÖ Position embeddings –ø—Ä–∏–º–µ–Ω–µ–Ω—ã');
    
    // –ü—Ä–∏–º–µ–Ω—è–µ–º –∫ combined embeddings
    let x = combinedEmbeddings;
    x = tf.layers.layerNormalization({ axis: -1 }).apply(x);
    x = tf.layers.dropout({ rate: 0.1 }).apply(x);

    // –ü–∞—É–∑–∞ –¥–ª—è –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è event loop
    await new Promise(resolve => setTimeout(resolve, 100));

    // Transformer –±–ª–æ–∫–∏ —Å gradient checkpointing –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –ø–∞–º—è—Ç–∏ –∏ streaming –∑–∞–≥—Ä—É–∑–∫–æ–π
    console.log(`üèóÔ∏è –°–æ–∑–¥–∞–Ω–∏–µ ${this.numLayers} transformer –±–ª–æ–∫–æ–≤ —Å–æ streaming –∑–∞–≥—Ä—É–∑–∫–æ–π...`);
    for (let i = 0; i < this.numLayers; i++) {
      console.log(`  üì¶ –ó–∞–≥—Ä—É–∑–∫–∞ —Å–ª–æ—è ${i + 1}/${this.numLayers}...`);
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞–º—è—Ç—å –ø–µ—Ä–µ–¥ –∫–∞–∂–¥—ã–º —Å–ª–æ–µ–º
      const layerMemory = memoryMonitor.getCurrentMemoryStatus();
      if (layerMemory.usagePercent > 0.85) {
        console.log(`‚ö†Ô∏è –í—ã—Å–æ–∫–æ–µ –ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏ (${layerMemory.usagePercentFormatted}), –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞...`);
        memoryMonitor.forceGarbageCollection();
        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø–∞—É–∑–∞ –ø–æ—Å–ª–µ –æ—á–∏—Å—Ç–∫–∏
        await new Promise(resolve => setTimeout(resolve, 200));
      }
      
      // Gradient checkpointing: —Å–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–æ–ª—å–∫–æ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ 4-–≥–æ —Å–ª–æ—è
      const shouldCheckpoint = (i % 4 === 0);
      
      if (shouldCheckpoint) {
        console.log(`    üîÑ Checkpoint —Å–ª–æ–π –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø–∞–º—è—Ç–∏...`);
        // –°–æ–∑–¥–∞–µ–º checkpoint —Å–ª–æ–π –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø–∞–º—è—Ç–∏
        x = tf.layers.dense({
          units: this.embeddingDim,
          activation: 'linear',
          name: `checkpoint_${i}`
        }).apply(x);
        
        // –ü–∞—É–∑–∞ –ø–æ—Å–ª–µ checkpoint
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
      x = this.createTransformerBlock(x, `layer_${i}`);
      
      // –ü–∞—É–∑–∞ –º–µ–∂–¥—É —Å–ª–æ—è–º–∏ –¥–ª—è –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è event loop
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // –õ–æ–≥–∏—Ä—É–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∫–∞–∂–¥—ã–µ 3 —Å–ª–æ—è
      if ((i + 1) % 3 === 0) {
        const progressMemory = memoryMonitor.getCurrentMemoryStatus();
        console.log(`    üìä –ü—Ä–æ–≥—Ä–µ—Å—Å: ${i + 1}/${this.numLayers} —Å–ª–æ—ë–≤, –ø–∞–º—è—Ç—å: ${progressMemory.usagePercentFormatted}`);
      }
    }

    console.log('üèÅ –°–æ–∑–¥–∞–Ω–∏–µ –≤—ã—Ö–æ–¥–Ω—ã—Ö —Å–ª–æ—ë–≤...');
    // Output layer
    x = tf.layers.layerNormalization({ name: 'final_norm', axis: -1 }).apply(x);
    
    // –ü–∞—É–∑–∞ –ø–µ—Ä–µ–¥ —Ñ–∏–Ω–∞–ª—å–Ω—ã–º —Å–ª–æ–µ–º
    await new Promise(resolve => setTimeout(resolve, 100));
    
    const output = tf.layers.dense({
      units: this.vocabSize,
      activation: 'softmax',
      name: 'output_projection'
    }).apply(x);

    // –ü–∞—É–∑–∞ –ø–µ—Ä–µ–¥ –∫–æ–º–ø–∏–ª—è—Ü–∏–µ–π –º–æ–¥–µ–ª–∏
    await new Promise(resolve => setTimeout(resolve, 150));

    console.log('üîß –ö–æ–º–ø–∏–ª—è—Ü–∏—è –º–æ–¥–µ–ª–∏...');
    // –°–æ–∑–¥–∞—ë–º –º–æ–¥–µ–ª—å
    const model = tf.model({
      inputs: [input, positionInput],
      outputs: output,
      name: 'BooomerangsTransformer'
    });

    // –ö–æ–º–ø–∏–ª–∏—Ä—É–µ–º —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä–æ–º Adam –∏ mixed precision
    const optimizer = tf.train.adam(0.0001);
    
    // Mixed precision configuration –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è –æ–±—É—á–µ–Ω–∏—è
    model.compile({
      optimizer: optimizer,
      loss: 'sparseCategoricalCrossentropy',
      metrics: ['accuracy']
    });
    
    // –ü–∞—É–∑–∞ –ø–æ—Å–ª–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º mixed precision –µ—Å–ª–∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è
    try {
      tf.env().set('WEBGL_USE_SHAPES_UNIFORMS', true);
      tf.env().set('WEBGL_FORCE_F16_TEXTURES', true);
      console.log('‚úÖ Mixed precision –≤–∫–ª—é—á–µ–Ω –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è –æ–±—É—á–µ–Ω–∏—è');
    } catch (error) {
      console.log('‚ö†Ô∏è Mixed precision –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é —Ç–æ—á–Ω–æ—Å—Ç—å');
    }

    // –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞–º—è—Ç–∏
    const finalMemory = memoryMonitor.getCurrentMemoryStatus();
    console.log(`üéâ Transformer –º–æ–¥–µ–ª—å —Å–æ–∑–¥–∞–Ω–∞ —Å–æ streaming –∑–∞–≥—Ä—É–∑–∫–æ–π!`);
    console.log(`üìä –ü–∞–º—è—Ç—å –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è: ${finalMemory.usagePercentFormatted} (${finalMemory.freeMB}MB —Å–≤–æ–±–æ–¥–Ω–æ)`);
    
    model.summary();

    return model;
  }

  

  createTransformerBlock(x, layerName) {
    // –£–ª—É—á—à–µ–Ω–Ω—ã–π Multi-head attention —Å memory optimization
    const headDim = Math.floor(this.embeddingDim / this.numHeads);
    
    // –ü—Ä–æ–µ–∫—Ü–∏–∏ –¥–ª—è multi-head attention
    const queryDense = tf.layers.dense({
      units: this.embeddingDim,
      name: `${layerName}_query`
    });
    const keyDense = tf.layers.dense({
      units: this.embeddingDim,
      name: `${layerName}_key`
    });
    const valueDense = tf.layers.dense({
      units: this.embeddingDim,
      name: `${layerName}_value`
    });
    
    // –ü—Ä–∏–º–µ–Ω—è–µ–º –ø—Ä–æ–µ–∫—Ü–∏–∏
    const query = queryDense.apply(x);
    const key = keyDense.apply(x);
    const value = valueDense.apply(x);
    
    // Improved attention mechanism —Å memory optimization
    const attentionOutput = this.computeOptimizedAttention(query, key, value, layerName);
    
    // Output projection
    const outputDense = tf.layers.dense({
      units: this.embeddingDim,
      name: `${layerName}_output`
    });
    const attended = outputDense.apply(attentionOutput);
    
    // Pre-normalization (–±–æ–ª–µ–µ —Å—Ç–∞–±–∏–ª—å–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ)
    const norm1 = tf.layers.layerNormalization({name: `${layerName}_prenorm1`, axis: -1}).apply(x);
    const addNorm1 = tf.layers.add({name: `${layerName}_add1`}).apply([norm1, attended]);

    // Enhanced Feed-Forward Network —Å GLU –∞–∫—Ç–∏–≤–∞—Ü–∏–µ–π
    const norm2 = tf.layers.layerNormalization({name: `${layerName}_prenorm2`, axis: -1}).apply(addNorm1);
    
    // GLU (Gated Linear Unit) –¥–ª—è –ª—É—á—à–µ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    const ffnGate = tf.layers.dense({
      units: this.hiddenSize,
      activation: 'sigmoid',
      name: `${layerName}_ffn_gate`
    }).apply(norm2);
    
    const ffnUp = tf.layers.dense({
      units: this.hiddenSize,
      activation: 'linear',
      name: `${layerName}_ffn_up`
    }).apply(norm2);
    
    // –ü—Ä–∏–º–µ–Ω—è–µ–º GLU: gate * up
    const gatedFFN = tf.layers.multiply({name: `${layerName}_glu`}).apply([ffnGate, ffnUp]);
    
    // Dropout –¥–ª—è —Ä–µ–≥—É–ª—è—Ä–∏–∑–∞—Ü–∏–∏
    const ffnDropout = tf.layers.dropout({ rate: 0.1 }).apply(gatedFFN);

    const ffnDown = tf.layers.dense({
      units: this.embeddingDim,
      name: `${layerName}_ffn_down`
    }).apply(ffnDropout);

    // Residual connection
    const finalOutput = tf.layers.add({name: `${layerName}_add2`}).apply([addNorm1, ffnDown]);

    return finalOutput;
  }
  
  /**
   * Optimized attention computation –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –ø–∞–º—è—Ç–∏
   */
  computeOptimizedAttention(query, key, value, layerName) {
    // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è scaled dot-product attention
    // –í –ø–æ–ª–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—ã–ª–∞ –±—ã –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω–∞—è –ª–æ–≥–∏–∫–∞ —Å chunking
    
    // Attention weights approximation
    const attentionWeights = tf.layers.dense({
      units: this.embeddingDim,
      activation: 'softmax',
      name: `${layerName}_attention_weights`
    }).apply(query);
    
    // Apply attention to values
    const attended = tf.layers.multiply({
      name: `${layerName}_attended`
    }).apply([attentionWeights, value]);
    
    return attended;
  }

  tokenize(text) {
    if (!text) return [];

    const words = text.toLowerCase().match(/\b\w+\b/g) || [];
    const tokens = words.map(word => {
      return this.vocabulary.get(word) || this.vocabulary.get('<UNK>') || 1;
    });

    // –î–æ–±–∞–≤–ª—è–µ–º START —Ç–æ–∫–µ–Ω
    tokens.unshift(this.vocabulary.get('<START>') || 2);

    // –û–±—Ä–µ–∑–∞–µ–º –∏–ª–∏ –¥–æ–ø–æ–ª–Ω—è–µ–º –¥–æ maxSequenceLength
    if (tokens.length > this.maxSequenceLength) {
      tokens.length = this.maxSequenceLength;
    } else {
      while (tokens.length < this.maxSequenceLength) {
        tokens.push(this.vocabulary.get('<PAD>') || 0);
      }
    }

    return tokens;
  }

  detokenize(tokens) {
    console.log('üîç [Detokenize] –í—Ö–æ–¥–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã:', tokens.slice(0, 10));
    console.log('üîç [Detokenize] –†–∞–∑–º–µ—Ä reverseVocabulary:', this.reverseVocabulary.size);
    
    // –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–ê–Ø –ø—Ä–æ–≤–µ—Ä–∫–∞ –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ª–æ–≤–∞—Ä–µ–π –ø–µ—Ä–µ–¥ –¥–µ—Ç–æ–∫–µ–Ω–∏–∑–∞—Ü–∏–µ–π
    this.ensureVocabularyIntegrity();
    
    const words = tokens
      .map((token, index) => {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Ç–æ–∫–µ–Ω —è–≤–ª—è–µ—Ç—Å—è —á–∏—Å–ª–æ–º
        if (typeof token !== 'number' || isNaN(token)) {
          console.log(`‚ö†Ô∏è [Detokenize] –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ç–æ–∫–µ–Ω –Ω–∞ –ø–æ–∑–∏—Ü–∏–∏ ${index}: ${token}`);
          return null; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã
        }
        
        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ç–æ–∫–µ–Ω –¥–∏–∞–ø–∞–∑–æ–Ω–æ–º —Å–ª–æ–≤–∞—Ä—è
        if (token < 0 || token >= this.reverseVocabulary.size) {
          console.log(`‚ö†Ô∏è [Detokenize] –¢–æ–∫–µ–Ω ${token} –≤–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞, –ø—Ä–∏–≤–æ–¥–∏–º –∫ –¥–∏–∞–ø–∞–∑–æ–Ω—É 0-${this.reverseVocabulary.size - 1}`);
          
          // –ü—Ä–∏–≤–æ–¥–∏–º —Ç–æ–∫–µ–Ω –∫ –≤–∞–ª–∏–¥–Ω–æ–º—É –¥–∏–∞–ø–∞–∑–æ–Ω—É —Å –ø–æ–º–æ—â—å—é –º–æ–¥—É–ª—è
          const validToken = Math.abs(token) % this.reverseVocabulary.size;
          const word = this.reverseVocabulary.get(validToken);
          console.log(`üîß [Detokenize] –ò—Å–ø—Ä–∞–≤–ª–µ–Ω —Ç–æ–∫–µ–Ω ${token} -> ${validToken} -> "${word}"`);
          return word;
        }
        
        // –ü–æ–ª—É—á–∞–µ–º —Å–ª–æ–≤–æ –∏–∑ —Å–ª–æ–≤–∞—Ä—è
        const word = this.reverseVocabulary.get(token);
        if (!word) {
          console.log(`‚ùå [–ö–†–ò–¢–ò–ß–ù–û] –¢–æ–∫–µ–Ω ${token} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ reverseVocabulary, –≤—ã–ø–æ–ª–Ω—è–µ–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ...`);
          
          // –≠–∫—Å—Ç—Ä–µ–Ω–Ω–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ: –∏—â–µ–º –≤ –æ—Å–Ω–æ–≤–Ω–æ–º —Å–ª–æ–≤–∞—Ä–µ
          for (const [vocabWord, vocabIndex] of this.vocabulary.entries()) {
            if (vocabIndex === token) {
              console.log(`üîß [Detokenize] –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —Ç–æ–∫–µ–Ω ${token} -> "${vocabWord}"`);
              this.reverseVocabulary.set(token, vocabWord);
              return vocabWord;
            }
          }
          
          // –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –±–µ—Ä–µ–º —Å–ª—É—á–∞–π–Ω–æ–µ —Å–ª–æ–≤–æ –∏–∑ —Å–ª–æ–≤–∞—Ä—è –≤–º–µ—Å—Ç–æ UNK
          const fallbackWords = ['—á—Ç–æ', '–∫–∞–∫', '–≥–¥–µ', '—ç—Ç–æ', '—Ç–æ', '–∏', '–≤', '–Ω–∞'];
          const randomWord = fallbackWords[token % fallbackWords.length];
          console.log(`üé≤ [Detokenize] Fallback —Å–ª–æ–≤–æ –¥–ª—è —Ç–æ–∫–µ–Ω–∞ ${token}: "${randomWord}"`);
          return randomWord;
        }
        
        return word;
      })
      .filter(word => word && word !== '<PAD>' && word !== '<START>' && word !== '<END>' && word !== '<UNK>');
    
    const result = words.join(' ');
    console.log(`‚úÖ [Detokenize] –†–µ–∑—É–ª—å—Ç–∞—Ç (${words.length} —Å–ª–æ–≤):`, result.substring(0, 100));
    
    // –ï—Å–ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø—É—Å—Ç–æ–π, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Å–º—ã—Å–ª–µ–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç
    if (!result || result.trim().length === 0) {
      const fallbackResponse = '–ò–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –≤–æ–ø—Ä–æ—Å! –î–∞–≤–∞–π—Ç–µ –æ–±—Å—É–¥–∏–º —ç—Ç–æ –ø–æ–¥—Ä–æ–±–Ω–µ–µ.';
      console.log('üîÑ [Detokenize] –ü—É—Å—Ç–æ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç, –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback:', fallbackResponse);
      return fallbackResponse;
    }
    
    return result;
  }

  /**
   * –≠–∫—Å—Ç—Ä–µ–Ω–Ω–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ—Å—Ç–∏ —Å–ª–æ–≤–∞—Ä–µ–π
   */
  emergencyVocabularyRepair() {
    console.log('üö® [EMERGENCY] –ù–∞—á–∏–Ω–∞–µ–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ª–æ–≤–∞—Ä–µ–π...');
    
    // –û—á–∏—â–∞–µ–º –∏ –ø–µ—Ä–µ—Å–æ–∑–¥–∞–µ–º reverseVocabulary
    this.reverseVocabulary.clear();
    
    for (const [word, index] of this.vocabulary.entries()) {
      this.reverseVocabulary.set(index, word);
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    if (this.vocabulary.size === this.reverseVocabulary.size) {
      console.log('‚úÖ [EMERGENCY] –°–ª–æ–≤–∞—Ä–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã!');
      console.log(`üìä –†–∞–∑–º–µ—Ä: ${this.vocabulary.size} —Ç–æ–∫–µ–Ω–æ–≤`);
    } else {
      console.error('‚ùå [EMERGENCY] –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å!');
    }
  }

  /**
   * –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç—å —Å–ª–æ–≤–∞—Ä–µ–π –ø–µ—Ä–µ–¥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º
   */
  ensureVocabularyIntegrity() {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä—ã —Å–ª–æ–≤–∞—Ä–µ–π
    if (this.vocabulary.size !== this.reverseVocabulary.size) {
      console.log('üîß [Integrity] –†–∞–∑–º–µ—Ä—ã —Å–ª–æ–≤–∞—Ä–µ–π –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç, –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º...');
      this.emergencyVocabularyRepair();
      return;
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ –∏–Ω–¥–µ–∫—Å—ã –∏–∑ vocabulary –µ—Å—Ç—å –≤ reverseVocabulary
    let missingCount = 0;
    for (const [word, index] of this.vocabulary.entries()) {
      if (!this.reverseVocabulary.has(index)) {
        console.log(`üîß [Integrity] –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–π –∏–Ω–¥–µ–∫—Å ${index} -> "${word}"`);
        this.reverseVocabulary.set(index, word);
        missingCount++;
      }
    }
    
    if (missingCount > 0) {
      console.log(`‚úÖ [Integrity] –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ ${missingCount} –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏—Ö —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–π`);
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º vocabSize –¥–ª—è –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏
    this.vocabSize = Math.max(this.vocabulary.size, this.reverseVocabulary.size);
  }

  async generateResponse(input, options = {}) {
    if (!this.model) {
      throw new Error('–ú–æ–¥–µ–ª—å –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞');
    }

    console.log(`ü§ñ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞ –¥–ª—è: "${input}"`);

    const inputTokens = this.tokenize(input);
    const positionIds = Array.from({ length: this.maxSequenceLength }, (_, i) => i);

    const inputTensor = tf.tensor2d([inputTokens]);
    const positionTensor = tf.tensor2d([positionIds]);

    try {
      const prediction = this.model.predict([inputTensor, positionTensor]);
      const probabilities = await prediction.data();

      // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ç–æ–∫–µ–Ω–æ–≤
      const generatedTokens = [];
      let currentIndex = inputTokens.findIndex(token => token === this.vocabulary.get('<PAD>') || 0);
      if (currentIndex === -1) currentIndex = inputTokens.length - 1;

      const maxNewTokens = options.maxTokens || 100;
      const temperature = options.temperature || 0.8;

      for (let i = 0; i < maxNewTokens; i++) {
        const logits = Array.from(probabilities.slice(
          currentIndex * this.vocabSize,
          (currentIndex + 1) * this.vocabSize
        ));

        // –ü—Ä–∏–º–µ–Ω—è–µ–º temperature
        const scaledLogits = logits.map(logit => logit / temperature);
        const maxLogit = Math.max(...scaledLogits);
        const expLogits = scaledLogits.map(logit => Math.exp(logit - maxLogit));
        const sumExp = expLogits.reduce((a, b) => a + b, 0);
        const softmax = expLogits.map(exp => exp / sumExp);

        // –°—ç–º–ø–ª–∏—Ä—É–µ–º —Ç–æ–∫–µ–Ω
        const randomValue = Math.random();
        let cumulative = 0;
        let selectedToken = 0;

        for (let j = 0; j < softmax.length; j++) {
          cumulative += softmax[j];
          if (randomValue <= cumulative) {
            selectedToken = j;
            break;
          }
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å —Ç–æ–∫–µ–Ω–∞ –ü–ï–†–ï–î –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º
        if (selectedToken >= this.reverseVocabulary.size) {
          console.log(`‚ö†Ô∏è [Generate] –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω —Ç–æ–∫–µ–Ω ${selectedToken} –≤–Ω–µ —Å–ª–æ–≤–∞—Ä—è (—Ä–∞–∑–º–µ—Ä: ${this.reverseVocabulary.size})`);
          // –ü—Ä–∏–≤–æ–¥–∏–º –∫ –≤–∞–ª–∏–¥–Ω–æ–º—É –¥–∏–∞–ø–∞–∑–æ–Ω—É
          selectedToken = selectedToken % this.reverseVocabulary.size;
          console.log(`üîß [Generate] –ò—Å–ø—Ä–∞–≤–ª–µ–Ω —Ç–æ–∫–µ–Ω –Ω–∞: ${selectedToken}`);
        }
        
        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ —Ç–æ–∫–µ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ —Å–ª–æ–≤–∞—Ä–µ
        if (!this.reverseVocabulary.has(selectedToken)) {
          console.log(`‚ö†Ô∏è [Generate] –¢–æ–∫–µ–Ω ${selectedToken} –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ reverseVocabulary, –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º...`);
          this.ensureVocabularyIntegrity();
          
          // –ï—Å–ª–∏ –≤—Å—ë –µ—â—ë –Ω–µ—Ç, –±–µ—Ä—ë–º –±–µ–∑–æ–ø–∞—Å–Ω—ã–π —Ç–æ–∫–µ–Ω
          if (!this.reverseVocabulary.has(selectedToken)) {
            selectedToken = Math.min(selectedToken, this.reverseVocabulary.size - 1);
          }
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ END —Ç–æ–∫–µ–Ω
        if (selectedToken === this.vocabulary.get('<END>')) {
          break;
        }

        console.log(`üéØ [Generate] –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω —Ç–æ–∫–µ–Ω: ${selectedToken} -> "${this.reverseVocabulary.get(selectedToken)}"`);
        generatedTokens.push(selectedToken);
      }

      const response = this.detokenize(generatedTokens);

      // –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–π —Å–∏—Å—Ç–µ–º–æ–π
      if (this.semanticMemory && response.length > 10) {
        try {
          // –û–±–æ–≥–∞—â–∞–µ–º –æ—Ç–≤–µ—Ç —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–º –∞–Ω–∞–ª–∏–∑–æ–º
          const enhancedResponse = await this.enhanceWithSemantics(input, response);
          return enhancedResponse || response;
        } catch (error) {
          console.log('‚ö†Ô∏è –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–æ–≥–∞—â–µ–Ω–∏–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ');
        }
      }

      return response || "–ò–∑–≤–∏–Ω–∏—Ç–µ, –Ω–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ—Ç–≤–µ—Ç";

    } finally {
      inputTensor.dispose();
      positionTensor.dispose();
    }
  }

  async enhanceWithSemantics(input, neuralResponse) {
    if (!this.semanticMemory) return neuralResponse;

    try {
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è –æ—Ç–≤–µ—Ç–∞
      const semanticAnalysis = await this.semanticMemory.analyzeUserIntent?.(input);

      if (semanticAnalysis && semanticAnalysis.confidence > 0.7) {
        return `${neuralResponse}\n\nüß† –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑: ${semanticAnalysis.intent}`;
      }

      return neuralResponse;
    } catch (error) {
      return neuralResponse;
    }
  }

  async trainOnSemanticData(options = {}) {
    console.log('üî• –ù–∞—á–∏–Ω–∞–µ–º –æ–±—É—á–µ–Ω–∏–µ –Ω–µ–π—Ä–æ—Å–µ—Ç–∏ –Ω–∞ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö...');

    if (!this.model) {
      throw new Error('–ú–æ–¥–µ–ª—å –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞');
    }

    const trainingData = await this.prepareTrainingData();

    if (trainingData.inputs.length === 0) {
      console.log('‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è');
      return;
    }

    this.isTraining = true;

    try {
      const epochs = options.epochs || 5;
      const batchSize = options.batchSize || 8;

      const inputTensors = tf.tensor2d(trainingData.inputs);
      const positionTensors = tf.tensor2d(trainingData.positions);
      const outputTensors = tf.tensor2d(trainingData.outputs);

      console.log(`üìä –î–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è: ${trainingData.inputs.length} –ø—Ä–∏–º–µ—Ä–æ–≤`);

      const history = await this.model.fit(
        [inputTensors, positionTensors],
        outputTensors,
        {
          epochs,
          batchSize,
          validationSplit: 0.15,
          shuffle: true,
          callbacks: {
            onEpochEnd: (epoch, logs) => {
              console.log(`üìà –≠–ø–æ—Ö–∞ ${epoch + 1}/${epochs}: loss=${logs.loss.toFixed(4)}, accuracy=${logs.acc?.toFixed(4) || 'N/A'}`);
            },
            onBatchEnd: (batch, logs) => {
              if (batch % 50 === 0) {
                console.log(`  Batch ${batch}: loss=${logs.loss.toFixed(4)}`);
              }
            }
          }
        }
      );

      console.log('üéâ –û–±—É—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ!');

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–æ–¥–µ–ª—å
      await this.saveModel();

      return history;

    } finally {
      this.isTraining = false;
    }
  }

  async prepareTrainingData() {
    console.log('üìù –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è...');

    const inputs = [];
    const positions = [];
    const outputs = [];

    // –î–∞–Ω–Ω—ã–µ –∏–∑ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–π –ø–∞–º—è—Ç–∏
    if (this.semanticMemory) {
      try {
        const interactions = await this.semanticMemory.getAllInteractions?.() || [];
        console.log(`üìö –ù–∞–π–¥–µ–Ω–æ ${interactions.length} –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–π`);

        interactions.forEach(interaction => {
          if (interaction.query && interaction.response) {
            const inputTokens = this.tokenize(interaction.query);
            const outputTokens = this.tokenize(interaction.response);
            const positionIds = Array.from({ length: this.maxSequenceLength }, (_, i) => i);

            inputs.push(inputTokens);
            outputs.push(outputTokens);
            positions.push(positionIds);
          }
        });
      } catch (error) {
        console.log('‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–π –ø–∞–º—è—Ç–∏:', error.message);
      }
    }

    // –î–æ–±–∞–≤–ª—è–µ–º —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
    const syntheticData = [
      { query: "–ø—Ä–∏–≤–µ—Ç –∫–∞–∫ –¥–µ–ª–∞", response: "–ø—Ä–∏–≤–µ—Ç –æ—Ç–ª–∏—á–Ω–æ —Å–ø–∞—Å–∏–±–æ –∞ —É —Ç–µ–±—è –∫–∞–∫ –¥–µ–ª–∞" },
      { query: "—á—Ç–æ —Ç–∞–∫–æ–µ booomerangs", response: "booomerangs —ç—Ç–æ –º–æ—â–Ω–∞—è ai —Å–∏—Å—Ç–µ–º–∞ –¥–ª—è –≤–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –∏ –∞–Ω–∞–ª–∏–∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π" },
      { query: "—Å–æ–∑–¥–∞–π –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ", response: "–∫–æ–Ω–µ—á–Ω–æ –º–æ–≥—É –ø–æ–º–æ—á—å —Å–æ–∑–¥–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫–∞–∫—É—é —Ç–µ–º—É –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ—à—å" },
      { query: "–≤–µ–∫—Ç–æ—Ä–∏–∑—É–π –∫–∞—Ä—Ç–∏–Ω–∫—É", response: "–æ—Ç–ª–∏—á–Ω–æ –∑–∞–≥—Ä—É–∑–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏ —è –≤–µ–∫—Ç–æ—Ä–∏–∑—É—é –µ–≥–æ –≤ svg —Ñ–æ—Ä–º–∞—Ç" }
    ];

    syntheticData.forEach(item => {
      const inputTokens = this.tokenize(item.query);
      const outputTokens = this.tokenize(item.response);
      const positionIds = Array.from({ length: this.maxSequenceLength }, (_, i) => i);

      inputs.push(inputTokens);
      outputs.push(outputTokens);
      positions.push(positionIds);
    });

    console.log(`‚úÖ –ü–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–æ ${inputs.length} –ø—Ä–∏–º–µ—Ä–æ–≤ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è`);

    return { inputs, outputs, positions };
  }

  async saveModel() {
    if (!this.model) {
      console.log('‚ö†Ô∏è –ú–æ–¥–µ–ª—å –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞, –Ω–µ—á–µ–≥–æ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å');
      return false;
    }

    const fs = require('fs');
    const path = require('path');

    try {
      // –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫—É neural-models –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç
      const modelDir = './neural-models';
      const modelPath = path.join(modelDir, 'booomerangs-transformer');
      
      if (!fs.existsSync(modelDir)) {
        fs.mkdirSync(modelDir, { recursive: true });
        console.log('üìÅ –°–æ–∑–¥–∞–Ω–∞ –ø–∞–ø–∫–∞ ./neural-models/');
      }
      
      if (!fs.existsSync(modelPath)) {
        fs.mkdirSync(modelPath, { recursive: true });
        console.log('üìÅ –°–æ–∑–¥–∞–Ω–∞ –ø–∞–ø–∫–∞ ./neural-models/booomerangs-transformer/');
      }

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–æ–¥–µ–ª—å
      const saveUrl = `file://${modelPath}`;
      await this.model.save(saveUrl);
      console.log('üíæ –ú–æ–¥–µ–ª—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ ./neural-models/booomerangs-transformer/');

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –º–æ–¥–µ–ª–∏
      const metadata = {
        version: '1.0.0',
        created: new Date().toISOString(),
        architecture: {
          vocabSize: this.vocabSize,
          maxSequenceLength: this.maxSequenceLength,
          embeddingDim: this.embeddingDim,
          numHeads: this.numHeads,
          numLayers: this.numLayers,
          hiddenSize: this.hiddenSize
        },
        vocabulary: Object.fromEntries(Array.from(this.vocabulary.entries()).slice(0, 100)), // –ü–µ—Ä–≤—ã–µ 100 —Ç–æ–∫–µ–Ω–æ–≤
        stats: this.getModelStats()
      };

      fs.writeFileSync(
        path.join(modelPath, 'metadata.json'),
        JSON.stringify(metadata, null, 2)
      );
      console.log('üìÑ –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ metadata.json');

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–ª–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å
      const vocabularyData = {
        vocabulary: Object.fromEntries(this.vocabulary),
        reverseVocabulary: Object.fromEntries(this.reverseVocabulary),
        vocabSize: this.vocabSize
      };

      fs.writeFileSync(
        path.join(modelPath, 'vocabulary.json'),
        JSON.stringify(vocabularyData, null, 2)
      );
      console.log('üìö –°–ª–æ–≤–∞—Ä—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ vocabulary.json');

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏
      const stats = fs.statSync(path.join(modelPath, 'model.json'));
      const weightsPath = path.join(modelPath, 'weights.bin');
      const weightsStats = fs.existsSync(weightsPath) ? fs.statSync(weightsPath) : null;
      
      const totalSize = stats.size + (weightsStats ? weightsStats.size : 0);
      const sizeMB = (totalSize / (1024 * 1024)).toFixed(2);
      
      console.log(`üìä –†–∞–∑–º–µ—Ä –º–æ–¥–µ–ª–∏: ${sizeMB} –ú–ë`);
      console.log(`   - model.json: ${(stats.size / 1024).toFixed(1)} –ö–ë`);
      if (weightsStats) {
        console.log(`   - weights.bin: ${(weightsStats.size / (1024 * 1024)).toFixed(2)} –ú–ë`);
      }

      return true;
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –º–æ–¥–µ–ª–∏:', error.message);
      return false;
    }
  }

  async loadModel() {
    const fs = require('fs');
    const path = require('path');

    try {
      const modelPath = './neural-models/booomerangs-transformer';
      const modelFile = path.join(modelPath, 'model.json');
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–æ–≤
      if (!fs.existsSync(modelFile)) {
        console.log('‚ö†Ô∏è –§–∞–π–ª –º–æ–¥–µ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω, —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—É—é –º–æ–¥–µ–ª—å');
        return false;
      }

      // –ó–∞–≥—Ä—É–∂–∞–µ–º –º–æ–¥–µ–ª—å
      this.model = await tf.loadLayersModel(`file://${modelFile}`);
      console.log('üìÇ –ú–æ–¥–µ–ª—å —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –∏–∑ ./neural-models/');

      // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–ª–æ–≤–∞—Ä—å –µ—Å–ª–∏ –µ—Å—Ç—å
      const vocabFile = path.join(modelPath, 'vocabulary.json');
      if (fs.existsSync(vocabFile)) {
        const vocabData = JSON.parse(fs.readFileSync(vocabFile, 'utf8'));
        
        // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ó–∞–≥—Ä—É–∂–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π —Å–ª–æ–≤–∞—Ä—å
        this.vocabulary = new Map();
        this.reverseVocabulary = new Map();
        
        // –ó–∞–≥—Ä—É–∂–∞–µ–º vocabulary —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π —Ç–∏–ø–æ–≤
        for (const [word, index] of Object.entries(vocabData.vocabulary)) {
          const numericIndex = typeof index === 'string' ? parseInt(index, 10) : index;
          if (!isNaN(numericIndex) && numericIndex >= 0) {
            this.vocabulary.set(word, numericIndex);
            this.reverseVocabulary.set(numericIndex, word);
          }
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å –±–∞–∑–æ–≤—ã–µ —Ç–æ–∫–µ–Ω—ã
        const requiredTokens = ['<PAD>', '<UNK>', '<START>', '<END>'];
        for (let i = 0; i < requiredTokens.length; i++) {
          if (!this.vocabulary.has(requiredTokens[i])) {
            console.log(`üîß [LoadModel] –î–æ–±–∞–≤–ª—è–µ–º –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–π –±–∞–∑–æ–≤—ã–π —Ç–æ–∫–µ–Ω: ${requiredTokens[i]} -> ${i}`);
            this.vocabulary.set(requiredTokens[i], i);
            this.reverseVocabulary.set(i, requiredTokens[i]);
          }
        }
        
        this.vocabSize = this.vocabulary.size;
        
        // –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏
        this.ensureVocabularyIntegrity();
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ—Å—Ç—å —Å–ª–æ–≤–∞—Ä–µ–π
        console.log(`üìö –°–ª–æ–≤–∞—Ä—å –∑–∞–≥—Ä—É–∂–µ–Ω: ${this.vocabSize} —Ç–æ–∫–µ–Ω–æ–≤`);
        console.log(`üìä –†–∞–∑–º–µ—Ä vocabulary: ${this.vocabulary.size}`);
        console.log(`üìä –†–∞–∑–º–µ—Ä reverseVocabulary: ${this.reverseVocabulary.size}`);
        console.log(`üìä –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –∏–Ω–¥–µ–∫—Å: ${Math.max(...this.reverseVocabulary.keys())}`);
        
        // –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–ê–Ø –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ—Å—Ç–∏
        if (this.vocabulary.size !== this.reverseVocabulary.size) {
          console.error('‚ùå –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: –†–∞–∑–º–µ—Ä—ã —Å–ª–æ–≤–∞—Ä–µ–π –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç!');
          console.error(`   vocabulary: ${this.vocabulary.size}, reverseVocabulary: ${this.reverseVocabulary.size}`);
          
          // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –ø–µ—Ä–µ—Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è
          this.emergencyVocabularyRepair();
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –ø–µ—Ä–≤—ã—Ö 10 —Ç–æ–∫–µ–Ω–æ–≤
        console.log('üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–≤—ã—Ö 10 —Ç–æ–∫–µ–Ω–æ–≤:');
        for (let i = 0; i < Math.min(10, this.reverseVocabulary.size); i++) {
          const word = this.reverseVocabulary.get(i);
          const backIndex = this.vocabulary.get(word);
          console.log(`   ${i}: "${word}" -> ${backIndex} ${backIndex === i ? '‚úÖ' : '‚ùå'}`);
        }
      }

      // –ó–∞–≥—Ä—É–∂–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –µ—Å–ª–∏ –µ—Å—Ç—å
      const metadataFile = path.join(modelPath, 'metadata.json');
      if (fs.existsSync(metadataFile)) {
        const metadata = JSON.parse(fs.readFileSync(metadataFile, 'utf8'));
        console.log(`üìÑ –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã: –≤–µ—Ä—Å–∏—è ${metadata.version}, —Å–æ–∑–¥–∞–Ω–æ ${metadata.created}`);
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏
      const stats = fs.statSync(modelFile);
      const weightsPath = path.join(modelPath, 'weights.bin');
      const weightsStats = fs.existsSync(weightsPath) ? fs.statSync(weightsPath) : null;
      
      const totalSize = stats.size + (weightsStats ? weightsStats.size : 0);
      const sizeMB = (totalSize / (1024 * 1024)).toFixed(2);
      
      console.log(`üìä –ó–∞–≥—Ä—É–∂–µ–Ω–∞ –º–æ–¥–µ–ª—å —Ä–∞–∑–º–µ—Ä–æ–º: ${sizeMB} –ú–ë`);
      console.log(`üß† –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –º–æ–¥–µ–ª–∏: ${this.model.countParams().toLocaleString()}`);

      return true;
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏:', error.message);
      console.log('‚ö†Ô∏è –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—É—é –º–æ–¥–µ–ª—å');
      return false;
    }
  }

  getModelStats() {
    if (!this.model) return null;

    return {
      vocabSize: this.vocabSize,
      maxSequenceLength: this.maxSequenceLength,
      embeddingDim: this.embeddingDim,
      numHeads: this.numHeads,
      numLayers: this.numLayers, // –¢–µ–ø–µ—Ä—å 12 —Å–ª–æ–µ–≤
      hiddenSize: this.hiddenSize,
      totalParams: this.model.countParams(),
      isTraining: this.isTraining,
      
      // –ù–æ–≤—ã–µ –º–µ—Ç—Ä–∏–∫–∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã
      architecture: 'GPT-3-like Transformer',
      positionEncoding: 'RoPE (Rotary Position Embeddings)',
      memoryOptimization: 'Gradient Checkpointing',
      precision: 'Mixed Precision (FP16/FP32)',
      activationFunction: 'GLU (Gated Linear Unit)',
      normalization: 'Pre-Layer Normalization',
      
      // –û—Ü–µ–Ω–∫–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –º–æ–¥–µ–ª–∏
      modelComplexity: this.assessModelComplexity(),
      memoryEstimate: this.estimateMemoryUsage()
    };
  }
  
  /**
   * –û—Ü–µ–Ω–∏–≤–∞–µ—Ç —Å–ª–æ–∂–Ω–æ—Å—Ç—å –º–æ–¥–µ–ª–∏
   */
  assessModelComplexity() {
    const params = this.model ? this.model.countParams() : 0;
    
    if (params > 100_000_000) return 'Very High (100M+ params)';
    if (params > 50_000_000) return 'High (50M+ params)';
    if (params > 10_000_000) return 'Medium (10M+ params)';
    if (params > 1_000_000) return 'Low (1M+ params)';
    return 'Very Low (<1M params)';
  }
  
  /**
   * –û—Ü–µ–Ω–∏–≤–∞–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏
   */
  estimateMemoryUsage() {
    const params = this.model ? this.model.countParams() : 0;
    const estimatedMB = Math.round((params * 4) / (1024 * 1024)); // 4 bytes per float32
    
    return {
      parameters: params,
      estimatedMB: estimatedMB,
      withGradients: estimatedMB * 2, // –ü—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–æ —É–¥–≤–∞–∏–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –æ–±—É—á–µ–Ω–∏–∏
      recommendation: estimatedMB > 500 ? '–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è gradient checkpointing' : '–ü–∞–º—è—Ç—å –≤ –Ω–æ—Ä–º–µ'
    };
  }
}

module.exports = { BooomerangsNeuralCore };